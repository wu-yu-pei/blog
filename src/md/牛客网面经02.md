1. 自我介绍
2. 怎么学习前端
3. 输入url到页面渲染完成
   1. 输入url http://www.baidu.com
   2. 域名解析(递归查询,)
      1. 首先查找浏览器缓存,如果有则使用,如果没有,去本机的host文件里查找缓存,如果有则使用,如果没有,经过向dns服务器发出请求
      2. 先向dns的顶级域名服务器发送请求,二级,三级,查到以后返回ip地址
   3. 浏览器拿到ip地址,浏览器的网络进程开始做发送请求的准备
      1. 首先三次握手
         1. 第一次握手浏览器发送一个syn = 1, 和一个序号 seq = x,标识要与服务器建立链接
         2. 第二次握手,服务器返回一个ack = x + 1, 和一个 syn =  1, 和一个 seq = y,表示确认收到请求,并希望与客户端简历链接
         3. 第三此握手, 浏览器收到服务器请求建立连接,给服务器返回一个ack = y + 1,表示同意建立连接
      2. 握手成功,服务器返回资源
      3. 四次挥手
         1. 第一次挥手: 浏览器请求断开连接 fin = 1 , seq = x表示要与服务器断开连接
         2. 第二次挥手: 服务器收到浏览器断开连接的请求, 发送一个ack = x + 1b表示收到浏览器的请求,
         3. 第三次挥手: 服务器确认没有资源需要发送,向浏览器发送一个fin = 1,sqq = y(2MLS)
         4. 浏览器收到服务器断开连接的请求,会一个ack = y + 1,表示同意断开连接,此时连接真正的断开
            - 问:为什么要三次握手,不是两次?为什么是4次挥手不是3次?为什么第三次挥手要等待2MlS?.............
      4. 在四次挥手的同时浏览器开始渲染html,css执行js(遇到async defer)....
      5. 浏览器开始解析html --> DOM Tree css --> CSS Tree
      6. DOM + CSS ---> Reader Tree
      7. 通过Reader绘制图层,渲染......
      8. 上述过程会交给不同的浏览器进程去做(网络进程,渲染进行,js进程....)
      9. 最终页面呈现

4. TCP/IP协议分层,TCP在哪一层
   1. 物理层--> 数据链路层 --> 网络层(ip) --> 传输层(tcp,udp) --> 应运层(http,https,ftd,pop)
5. 三次握手,四次会收为什么挥手多一次
   1. 保证与客户端断开连接,如果没有最后一次挥手,确保双放都断开连接
   2. 为什么是三次握手而不是两次,为了不浪费服务器资源 假设第二次请求由于网络延迟而延迟到达,就立马可以建立连接,还有就是为了实现可靠传输,握手期间双方会确定信息(序列号,滑动窗口大小,等..)
6. 浏览器缓存,强缓存、协商缓存,为什么cache-control优先级更高
   1. 强缓存 exprice(max-age...), cacht-control(no-strore, no-cache, private, public..)
   2. cache-control是http1.多的产物,对不支持http2的要优先使用ca....
   3. 若缓存(Etag/if-no-Math, Last-modefil, if-Modifle-since...)
7. no-cache,no-store分别代表什么?
   1. no-cache:代表不使用强缓存,使用协商缓存
   2. no-store代表不使用缓存
8. html、css、js文件会放在磁盘缓存还是内存缓存
   1. 都有可能
   2. 大文件一般放在磁盘,小文件一版放在内存中
   3. dist cache memary cache .......
9. DOM树和css om树是互斥的还是同时的
   1. 应该是同时的
10. JS脚本阻塞DOM构建,js脚本会不会对css om树影响
    1. 不会吧 ,js不会直接操作样式
11. 重绘,重排概念
    1. 重排:(回流) 元素的位置,尺寸,大小等几何尺寸发送变化会触发
    2. 重绘:颜色等发生变化会触发
    3. 回流会对性能造成影响,(节流,防抖优化)
12. 看题说输出
    1. ![截图](../mdimg/this%E9%97%AE%E9%A2%98.png)
13. 箭头函数和普通函数的区别,箭头函数如何表示不定长的参数
    1. 箭头函数没有this,this会执向其上下文的this
    2. 不能当构造函数,没有arguments
    3. ...args
14. 有哪些类型的作用域
    1. 块级作用域(函数作用域)
    2. 全局作用域
15. var let const区别
    1. var 全局 挂在window上
    2. let 局部 有作用域 暂时性死区
    3. const 有作用域 暂时想死去 定义后不能修改
16. 实现eventBus
    1. 之前实现过,挺简单的
17. 一个算法:岛屿数量
    1. 没写过
18. 提问阶段:

** 一面结束**