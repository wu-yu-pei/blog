#### 类型体操

一.

> 实现 TS 内置的 Pick<T, K>，但不可以使用它。从类型 T 中选择出属性 K，构造成一个新的类型。

```js
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}


type MyPick<T, K extends keyof T> = {
  [props in K]: T[K];
};

type TodoPreview = MyPick<Todo, 'title' | 'completed'>;
```

二.

> 不要使用内置的 Readonly<T>，自己实现一个。该 Readonly 会接收一个 泛型参数，并返回一个完全一样的类型，只是所有属性都会被 readonly 所修饰。也就是不可以再对该对象的属性赋值。

```js
interface Todo {
  title: string;
  description: string;
}

type MyReadonly<T> = {
  readonly [key in keyof T]: T[key];
};

const todo: MyReadonly<Todo> = {
  title: 'Hey',
  description: 'foobar',
};

todo.title = 'Hello'; // Error: cannot reassign a readonly property
todo.description = 'barFoo'; // Error: cannot reassign a readonly property
```

三.

> 传入一个元组类型，将这个元组类型转换为对象类型，这个对象类型的键/值都是从元组中遍历出来。

```js
const tuple = ['tesla', 'model 3', 'model X', 'model Y'];

// type TupleToObject<T> = {
//   [key in keyof T]: T[key];
// };

type TupleToObject<T extends string[]> = { [K in T[number]]: K };

type result = TupleToObject<typeof tuple>; // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}

```

四.

> 实现一个通用 First<T>，它接受一个数组 T 并返回它的第一个元素的类型。

```js
type arr1 = ['a', 'b', 'c'];
type arr2 = [3, 2, 1];

// type First<T extends any[]> = T extends [infer F, ...infer R] ? F : never;

type First<T extends any[]> = T extends [] ? never : T[0];

// type First<T extends any[]> = T[0];

type head1 = First<arr1>; // expected to be 'a'
type head2 = First<arr2>; // expected to be 3
```

五.

> 实现内置的 Exclude <T, U>类型，但不能直接使用它本身。从联合类型 T 中排除 U 的类型成员，来构造一个新的类型。

```js
// Exclude <T, U>
type A = {
  name: string;
  age: number;
};

type B = {
  name: string;
  age: number;
  class: string;
};

// 我的:
// type MyExclude<T, U extends T> = {
//   [K in keyof T]: T[K];
// };

// github:
type MyExclude<T, U> = T extends U ? never : T

type C = MyExclude<A, B>;

```

今天就5题吧,继续研究...