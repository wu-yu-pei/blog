#### 类型体操

> 从一个类型　构造另一个类型

1.数组从新构造 push

```js
type tuple = [1, 2, 3];

type Push<T extends unknown[], V> = [...T, V];

const a: Push<tuple, 5> = [1, 2, 3, 5];
```

2.数组从新构造 unshifp

```js

type tuple = [1, 2, 3];

type Push<T extends unknown[], V> = [V, ...T];

const a: Push<tuple, 5> = [5, 1, 2, 3];
```

3.数组从新构造 shift

```js
type tuple = [1, 2, 3];

type Unshif<T extends unknown[]> = T extends [infer Frist, ...infer Arg] ? Arg : never;

const a: Unshif<tuple> = [2, 3];
```

4.数组从新构造 pop

```js
type tuple = [1, 2, 3];

type Unshif<T extends unknown[]> = T extends [...infer Arg, infer Last] ? Arg : never;

const a: Unshif<tuple> = [1, 2];
```

5.数组的从新构造 合并两个

```js
type a = [1, 2];
type b = ['a', 'b'];

type HeBing<One extends unknown[], Two extends unknown[]> = One extends [
infer OneFirst,
infer OneTwo
]
? Two extends [infer TwoFirst, infer TwoTwo]
? [[OneFirst, TwoFirst], [OneTwo, TwoTwo]]
: []
: [];

const c: HeBing<a, b> = [
[1, 'a'],
[2, 'b'],
];
```

6.数组的从新构造 合并多个

```js
type a = [1, 2, 3];
type b = ['a', 'b', 'c'];

type HeBing<One extends unknown[], Two extends unknown[]> = One extends [
infer First,
...infer OneArg
]
? Two extends [infer Two, ...infer TwoArg]
? [[First, Two], ...HeBing<OneArg, TwoArg>]
: []
: [];

const a: HeBing<a, b> = [
[1, 'a'],
[2, 'b'],
[3, 'c'],
];
```

7.字符串的构造 array Array

```js
type str = 'array';

type CapitalizeStr<T extends string> = T extends `${infer FirstWord}${infer Arg}`
? `${Uppercase<FirstWord>}${Arg}`
: T;

const a: CapitalizeStr<str> = 'Array';
```

8.字符串的构造 dong_dong_dong 到 dongDongDong 的变换。

```js
type CamelCase<Str extends string> = Str extends `${infer Left}_${infer Right}${infer Rest}`
? `${Left}${Uppercase<Right>}${CamelCase<Rest>}`
: Str;
```

> 就学这么多

!\_!
