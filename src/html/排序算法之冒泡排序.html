<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Growing-排序算法之冒泡排序</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/prism.min.js"></script>
    <link
      href="https://cdn.bootcdn.net/ajax/libs/prism-themes/1.9.0/prism-one-dark.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
      integrity="sha512-c42qTSw/wPZ3/5LBzD+Bw5f7bSF2oxou6wEb+I/lqeaKV5FDIfMvvRp772y4jcJLKuGUOpbJMdg/BTl50fJYAw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link rel="icon" href="../../favicon.ico" />
    <link rel="stylesheet" href="../css/base.css" />
    <link rel="stylesheet" href="../css/notify.css" />
    <link rel="stylesheet" href="../css/newsprint.css" />
    <link rel="stylesheet" href="../css/article.css" />
  </head>

  <body>
    <div class="nav">
      <div class="home">
        <a href="../../pageList/index.html"><img src="../img/list.svg" alt="" /></a>
      </div>
      <div class="auther">
        <span>G</span>
        <span>r</span>
        <span>o</span>
        <span>w</span>
        <span>i</span>
        <span>n</span>
        <span>g</span>
        <span>/</span>
        <span>A</span>
        <span>r</span>
        <span>t</span>
        <span>i</span>
        <span>c</span>
        <span>l</span>
        <span>e</span>
      </div>
      <div class="github">
        <a href="https://github.com/wu-yu-pei"><img src="../img/github.svg" alt="" /></a>
      </div>
    </div>
    <div class="content">
      <h1>排序算法之冒泡排序</h1>
      <h4 id="">冒泡排序</h4>
<p>基本思路分析</p>
<blockquote>
  <p>思路分析摘自 修言 数据结构与算法 排序篇</p>
</blockquote>
<p>冒泡排序的过程，就是从第一个元素开始，重复比较相邻的两个项，若第一项比第二项更大，则交换两者的位置；反之不动。
每一轮操作，都会将这一轮中最大的元素放置到数组的末尾。假如数组的长度是 n，那么当我们重复完 n 轮的时候，整个数组就有序了。</p>
<p>真实排序过程演示
下面我们基于冒泡排序的思路，尝试对以下数组进行排序：</p>
<p>[5, 3, 2, 4, 1]
首先，将第一个元素 5 和它相邻的元素 3 作比较，发现 5 比 3 大，故将 5 和 3 交换：</p>
<p>[3, 5, 2, 4, 1]
↑ ↑
将第二个元素 5 和第三个元素 2 作比较，发现 5 比 2 大，故将 5 和 2 交换：</p>
<p>[3, 2, 5, 4, 1]
↑ ↑
将第三个元素 5 和第四个元素 4 作比较，发现 5 比 4 大，故将 5 和 4 交换：</p>
<p>[3, 2, 4, 5, 1]
↑ ↑
将第四个元素 5 和第五个元素 1 作比较，发现 5 比 1 大，故将 5 和 1 交换：</p>
<p>[3, 2, 4, 1, 5]
↑ ↑
至此我们就完成了一轮排序，此时，五个数中最大的数字 5 仿佛气泡浮出水面一样，被”冒“到了数组顶部。这也是冒泡排序得名的原因。</p>
<p>重复上面的操作，我们继续从第一个元素开始看起。比较 3 和 2，发现 3 比 2 大，交换两者：</p>
<p>[2, 3, 4, 1, 5]
↑ ↑
比较 3 和 4，发现 3 比 4 小，符合从小到大排列的原则，故保持不动：</p>
<p>[2, 3, 4, 1, 5]
↑ ↑
比较 4 和 1，发现 4 比 1 大，交换两者：</p>
<p>[2, 3, 1, 4, 5]
↑ ↑
比较 4 和 5，发现 4 比 5 小，符合从小到大排列的原则，故保持不动：</p>
<p>[2, 3, 1, 4, 5]
↑ ↑
以上我们完成了第二轮排序，至此，五个数中第二大的数字 4 也被”冒“到了数组相对靠后的位置。
沿着这个思路往下走，仍然是从第一个元素开始，比较 2 和 3。发现 2 比 3 小，符合排序原则，故保持不动：</p>
<p>[2, 3, 1, 4, 5]
↑ ↑
接着走下去，比较 3 和 1，发现 3 比 1 大，交换两者：</p>
<p>[2, 1, 3, 4, 5]
↑ ↑
比较 3 和 4，发现 3 比 4 小，符合排序原则，故保持不动：</p>
<p>[2, 1, 3, 4, 5]
↑ ↑
比较 4 和 5，发现 4 比 5 小，符合排序原则，故保持不动：</p>
<p>[2, 1, 3, 4, 5]
↑ ↑
以上我们完成了第二轮排序，至此，五个数中第三大的数字 3 被”冒“到了倒数第三个的位置。
继续我们的循环，从当前的第一个元素 2 开始，比较 2 和相邻元素 1，发现 2 比 1 大，交换两者：</p>
<p>[1, 2, 3, 4, 5]
↑ ↑
接下来仍然会对剩余的元素进行相邻元素比较，但由于不再发生交换，所以我们这里简写一下每一步对应的相邻元素关系：</p>
<p>[1, 2, 3, 4, 5]
↑ ↑
[1, 2, 3, 4, 5]
↑ ↑
[1, 2, 3, 4, 5]
↑ ↑
[1, 2, 3, 4, 5]
↑ ↑
经过第四轮冒泡，整个数组已经完全达到了有序状态。不过，冒泡排序的逻辑并不会因为数组有序就立刻停下来——”从头到尾遍历数组，对比+交换每两个相邻元素“这套逻辑到底要执行多少次，按照我们目前的基本思路来看，是完全由数组中元素的个数来决定的：每一次从头到尾的遍历都只能定位到一个元素的位置，因此元素有多少个，总的循环就要执行多少轮。
在这个例子中，总的元素有 5 个，因此理论上来说还有一轮从头到尾的循环要走。</p>
<p><strong>代码实现:</strong></p>
<pre><code class="js language-js">let arr = [8, 7, -8, 15, 4, 0, 2, 1];

// 1.0
function sort(arr) {
  for (let i = 0; i &lt; arr.length; i++) {
    for (let j = 0; j &lt; arr.length - 1; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}

// 1.1
function sort(arr) {
  for (let i = 0; i &lt; arr.length; i++) {
    // j = arr.length - i - 1
    for (let j = 0; j &lt; arr.length - i - 1; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}

// 1.3
function sort(arr) {
  for (let i = 0; i &lt; arr.length; i++) {
    // 标志位
    let flag = false;
    for (let j = 0; j &lt; arr.length - i - 1; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        flag = true;
      }
    }
    // 直接放过 优化时间复杂度
    if (flag == false) return arr;
  }
  return arr;
}

sort(arr);
</code></pre>
      <div class="end">----本文结束----</div>
      <div class="page">
        <a
          href="https://wu-yu-pei.github.io/leetcode/src/html/刷题暂停.html"
          class="pre"
        >
          <img src="../img/leftArrow.svg" alt="" />
          刷题暂停
        </a>
        <a
          href="https://wu-yu-pei.github.io/leetcode/src/html/排序算法之归并排序.html"
          class="next"
        >
          排序算法之归并排序
          <img src="../img/rightArrow.svg" alt="" />
        </a>
      </div>
    </div>
    <div class="fotter">
      <p>All articles written with ❤ by Wu Yupei</p>
      <p>Github · Gieee · QQ · WeChat</p>
    </div>
    <script src="../js/click.js"></script>
    <script src="../js/scroll.js"></script>
    <script src="../js/notify.js"></script>
  </body>
</html>
